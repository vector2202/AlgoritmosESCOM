<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Huffman Algorithm: HuffmanStructures.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Huffman Algorithm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HuffmanStructures.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Las esctructuras y funciones usadas en el Algoritmo de Huffman.  
<a href="#details">More...</a></p>

<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbits.html">bits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Almacena el byte correspondiente, su tama√±o y sus bits de la codificacion de Huffman.  <a href="structbits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdata.html">data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Almacena un byte y las veces que aparecio en el archivo.  <a href="structdata.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnode.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estructura del arbol de Huffman.  <a href="structnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeap.html">Heap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Almacena un arreglo de nodos.  <a href="structHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:abf81647b623c39b6e4e43581ddf666fe"><td class="memItemLeft" align="right" valign="top"><a id="abf81647b623c39b6e4e43581ddf666fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PESOBIT</b>(bpos)&#160;&#160;&#160;1 &lt;&lt; bpos</td></tr>
<tr class="separator:abf81647b623c39b6e4e43581ddf666fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a6bee91ee9e4ae83cccc49d35b864"><td class="memItemLeft" align="right" valign="top"><a id="a3c2a6bee91ee9e4ae83cccc49d35b864"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CONSULTARBIT</b>(var,  bpos)&#160;&#160;&#160;(*(unsigned *)&amp;var &amp; PESOBIT(bpos)) ? 1 : 0</td></tr>
<tr class="separator:a3c2a6bee91ee9e4ae83cccc49d35b864"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a705af815969c97892c0aaaa658f6c88c"><td class="memItemLeft" align="right" valign="top"><a id="a705af815969c97892c0aaaa658f6c88c"></a>
typedef struct <a class="el" href="structHeap.html">Heap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Heap</b></td></tr>
<tr class="separator:a705af815969c97892c0aaaa658f6c88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5bad7da515387fa08a9179b311723e2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a5bad7da515387fa08a9179b311723e2a">isEmpty</a> (struct <a class="el" href="structnode.html">node</a> *root)</td></tr>
<tr class="separator:a5bad7da515387fa08a9179b311723e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b35899288a51584c43613160971dc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a86b35899288a51584c43613160971dc8">isLeaf</a> (struct <a class="el" href="structnode.html">node</a> *root)</td></tr>
<tr class="separator:a86b35899288a51584c43613160971dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0c0384c7064b8c1011dd46b520f49e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a2c0c0384c7064b8c1011dd46b520f49e">pushTree</a> (struct <a class="el" href="structnode.html">node</a> *root, unsigned char byte, int frecuency)</td></tr>
<tr class="separator:a2c0c0384c7064b8c1011dd46b520f49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ab18632fd2e00d4bd9206a4d50e024"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#ad5ab18632fd2e00d4bd9206a4d50e024">mergeNodes</a> (struct <a class="el" href="structnode.html">node</a> *node1, struct <a class="el" href="structnode.html">node</a> *node2)</td></tr>
<tr class="separator:ad5ab18632fd2e00d4bd9206a4d50e024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b934a3197005f4d1d1343cd895ab0ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a8b934a3197005f4d1d1343cd895ab0ab">getBits</a> (struct <a class="el" href="structnode.html">node</a> *HuffmanTree, struct <a class="el" href="structbits.html">bits</a> bytesCode[], int <a class="el" href="structbits.html">bits</a>, int bitsSize)</td></tr>
<tr class="separator:a8b934a3197005f4d1d1343cd895ab0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f60f86711915027587cc7e51824530f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a9f60f86711915027587cc7e51824530f">getCharacters</a> (struct <a class="el" href="structnode.html">node</a> *HuffmanTree, unsigned char *cadena, int *posInString, int posInBits, unsigned char *byteToWrite)</td></tr>
<tr class="separator:a9f60f86711915027587cc7e51824530f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa991c0877759cd631105ec72160fb70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structHeap.html">Heap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#afa991c0877759cd631105ec72160fb70">CreateHeap</a> (int capacity)</td></tr>
<tr class="separator:afa991c0877759cd631105ec72160fb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8480031dd4983d594484e5901c625109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a8480031dd4983d594484e5901c625109">insert</a> (<a class="el" href="structHeap.html">Heap</a> *heap, struct <a class="el" href="structnode.html">node</a> *<a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="separator:a8480031dd4983d594484e5901c625109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf9aa045cba65e7fbb1f3a9df39f7e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a7cf9aa045cba65e7fbb1f3a9df39f7e7">heapify_bottom_top</a> (<a class="el" href="structHeap.html">Heap</a> *heap, int index)</td></tr>
<tr class="separator:a7cf9aa045cba65e7fbb1f3a9df39f7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b6a0088c5c75b15e4b9d2987f44c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#af0b6a0088c5c75b15e4b9d2987f44c97">heapify_top_bottom</a> (<a class="el" href="structHeap.html">Heap</a> *heap, int parent_node)</td></tr>
<tr class="separator:af0b6a0088c5c75b15e4b9d2987f44c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d006cd7d0d91e05dd6c94fccb270a8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a20d006cd7d0d91e05dd6c94fccb270a8">PopMin</a> (<a class="el" href="structHeap.html">Heap</a> *heap)</td></tr>
<tr class="separator:a20d006cd7d0d91e05dd6c94fccb270a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af3472248b7ad1d7aef69d68fed158a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a3af3472248b7ad1d7aef69d68fed158a">insertTree</a> (struct <a class="el" href="structdata.html">data</a> bytesFrecuency[], struct <a class="el" href="structnode.html">node</a> roots[], <a class="el" href="structHeap.html">Heap</a> *heap)</td></tr>
<tr class="separator:a3af3472248b7ad1d7aef69d68fed158a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f02d9fd6fce765ac0cb694a3baa4b28"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a7f02d9fd6fce765ac0cb694a3baa4b28">mergeTrees</a> (<a class="el" href="structHeap.html">Heap</a> *heap)</td></tr>
<tr class="separator:a7f02d9fd6fce765ac0cb694a3baa4b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Las esctructuras y funciones usadas en el Algoritmo de Huffman. </p>
<dl class="section author"><dt>Author</dt><dd>Victor Torres </dd>
<dd>
Leilani Sotelo </dd>
<dd>
Guillermo Sanchez </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>

<p class="definition">Definition in file <a class="el" href="">HuffmanStructures.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="afa991c0877759cd631105ec72160fb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa991c0877759cd631105ec72160fb70">&#9670;&nbsp;</a></span>CreateHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structHeap.html">Heap</a>* CreateHeap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Crea una estructura <a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a> en memoria dinamica dada su capacidad, la cual es un arreglo de nodos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>es la capacidad que queremos que tenga heap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>el apuntador a la estructura heap creada </dd></dl>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;{</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <a class="code" href="structHeap.html">Heap</a> *heap = (<a class="code" href="structHeap.html">Heap</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structHeap.html">Heap</a>));</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> = 0;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    heap-&gt;<a class="code" href="structHeap.html#a6c59b42ad9bf8ff10feffe29bd0dfb44">capacity</a> = capacity;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    heap-&gt;arrayOfNodes = (<span class="keyword">struct </span><a class="code" href="structnode.html">node</a> **)malloc(capacity * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structnode.html">node</a>));</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">return</span> heap;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;}</div>
<div class="ttc" id="astructHeap_html"><div class="ttname"><a href="structHeap.html">Heap</a></div><div class="ttdoc">Almacena un arreglo de nodos.</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:70</div></div>
<div class="ttc" id="astructHeap_html_a43405fb00a35877037a84f080aaf0aa7"><div class="ttname"><a href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">Heap::count</a></div><div class="ttdeci">int count</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:72</div></div>
<div class="ttc" id="astructHeap_html_a6c59b42ad9bf8ff10feffe29bd0dfb44"><div class="ttname"><a href="structHeap.html#a6c59b42ad9bf8ff10feffe29bd0dfb44">Heap::capacity</a></div><div class="ttdeci">int capacity</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:73</div></div>
<div class="ttc" id="astructnode_html"><div class="ttname"><a href="structnode.html">node</a></div><div class="ttdoc">Estructura del arbol de Huffman.</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:54</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00073">Heap::capacity</a>, and <a class="el" href="#l00072">Heap::count</a>.</p>

</div>
</div>
<a id="a8b934a3197005f4d1d1343cd895ab0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b934a3197005f4d1d1343cd895ab0ab">&#9670;&nbsp;</a></span>getBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getBits </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>HuffmanTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbits.html">bits</a>&#160;</td>
          <td class="paramname"><em>bytesCode</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitsSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtiene la codificaciond de Huffman correspondiente a los bytes. La guarda en un arreglo de struct junto con el tama√±o de bits correspondiente. La codificacion se obtiene recorriendo el arbol inorder y cada vez registramos un 0 o un 1 si nos vamos a la izquierda o derecha, al final si es nodo hoja, guardamos lo que llevamos</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">HuffmanTree</td><td>el arbol de Huffman </td></tr>
    <tr><td class="paramname">bytesCode</td><td>el arreglo donde se guarda el byte, su codificacion y tama√±o </td></tr>
    <tr><td class="paramname">bits</td><td>los bits con los que inicia el nodo que por defecto es 0 </td></tr>
    <tr><td class="paramname">bitsSize</td><td>el tama√±o de los bits que por defecto es 0 </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="HuffmanStructures_8h.html#a5bad7da515387fa08a9179b311723e2a">isEmpty</a>(HuffmanTree))</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    {                                                                     <span class="comment">//if notempty</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#a8b934a3197005f4d1d1343cd895ab0ab">getBits</a>(HuffmanTree-&gt;<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a>, bytesCode, (<a class="code" href="structbits.html">bits</a> &lt;&lt; 1), sizeBits + 1); <span class="comment">// irte al nodo izq, sumandole un 0</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="HuffmanStructures_8h.html#a86b35899288a51584c43613160971dc8">isLeaf</a>(HuffmanTree))</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        {</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;            <span class="keywordtype">int</span> hashKey = HuffmanTree-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.<a class="code" href="structdata.html#af27bef4b0c09016974738690d89009f4">byte</a>;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            bytesCode[hashKey].<a class="code" href="structbits.html#a3e6347128690b18f31f4c12ba62f7796">bits</a> = <a class="code" href="structbits.html">bits</a>;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            bytesCode[hashKey].<a class="code" href="structbits.html#a5f11169dff38718ff57b0dc73b2da9e2">byte</a> = HuffmanTree-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.<a class="code" href="structdata.html#af27bef4b0c09016974738690d89009f4">byte</a>;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            bytesCode[hashKey].<a class="code" href="structbits.html#a15a0d838e9d402ead452a092c4f27e57">sizeBits</a> = sizeBits;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#a8b934a3197005f4d1d1343cd895ab0ab">getBits</a>(HuffmanTree-&gt;<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a>, bytesCode, (<a class="code" href="structbits.html">bits</a> &lt;&lt; 1) + 1, sizeBits + 1); <span class="comment">//irte al nodo der sumandole un 1</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    }</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_a5bad7da515387fa08a9179b311723e2a"><div class="ttname"><a href="HuffmanStructures_8h.html#a5bad7da515387fa08a9179b311723e2a">isEmpty</a></div><div class="ttdeci">int isEmpty(struct node *root)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:9</div></div>
<div class="ttc" id="aHuffmanStructures_8h_html_a86b35899288a51584c43613160971dc8"><div class="ttname"><a href="HuffmanStructures_8h.html#a86b35899288a51584c43613160971dc8">isLeaf</a></div><div class="ttdeci">int isLeaf(struct node *root)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:11</div></div>
<div class="ttc" id="aHuffmanStructures_8h_html_a8b934a3197005f4d1d1343cd895ab0ab"><div class="ttname"><a href="HuffmanStructures_8h.html#a8b934a3197005f4d1d1343cd895ab0ab">getBits</a></div><div class="ttdeci">void getBits(struct node *HuffmanTree, struct bits bytesCode[], int bits, int bitsSize)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:32</div></div>
<div class="ttc" id="astructbits_html"><div class="ttname"><a href="structbits.html">bits</a></div><div class="ttdoc">Almacena el byte correspondiente, su tama√±o y sus bits de la codificacion de Huffman.</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:25</div></div>
<div class="ttc" id="astructbits_html_a15a0d838e9d402ead452a092c4f27e57"><div class="ttname"><a href="structbits.html#a15a0d838e9d402ead452a092c4f27e57">bits::sizeBits</a></div><div class="ttdeci">int sizeBits</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:27</div></div>
<div class="ttc" id="astructbits_html_a3e6347128690b18f31f4c12ba62f7796"><div class="ttname"><a href="structbits.html#a3e6347128690b18f31f4c12ba62f7796">bits::bits</a></div><div class="ttdeci">int bits</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:28</div></div>
<div class="ttc" id="astructbits_html_a5f11169dff38718ff57b0dc73b2da9e2"><div class="ttname"><a href="structbits.html#a5f11169dff38718ff57b0dc73b2da9e2">bits::byte</a></div><div class="ttdeci">unsigned char byte</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:26</div></div>
<div class="ttc" id="astructdata_html_af27bef4b0c09016974738690d89009f4"><div class="ttname"><a href="structdata.html#af27bef4b0c09016974738690d89009f4">data::byte</a></div><div class="ttdeci">int byte</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:41</div></div>
<div class="ttc" id="astructnode_html_a214bcb685bd669e3742fb8cf0b1baf36"><div class="ttname"><a href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">node::left</a></div><div class="ttdeci">struct node * left</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:55</div></div>
<div class="ttc" id="astructnode_html_a567ee9cc94939a22d38d21b7b5db2023"><div class="ttname"><a href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">node::right</a></div><div class="ttdeci">struct node * right</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:56</div></div>
<div class="ttc" id="astructnode_html_ac559c68027629d3f87ee49a6f8c839e6"><div class="ttname"><a href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">node::data</a></div><div class="ttdeci">struct data data</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:57</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00028">bits::bits</a>, <a class="el" href="#l00026">bits::byte</a>, <a class="el" href="#l00041">data::byte</a>, <a class="el" href="#l00057">node::data</a>, <a class="el" href="#l00009">isEmpty()</a>, <a class="el" href="#l00011">isLeaf()</a>, <a class="el" href="#l00055">node::left</a>, <a class="el" href="#l00056">node::right</a>, and <a class="el" href="#l00027">bits::sizeBits</a>.</p>

</div>
</div>
<a id="a9f60f86711915027587cc7e51824530f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f60f86711915027587cc7e51824530f">&#9670;&nbsp;</a></span>getCharacters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getCharacters </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>HuffmanTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>cadena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>posInString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posInBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>byteToWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtiene el byte correspondiente a la codificacion de Huffman. Recorre el arbol analizando si es 0 o 1 el bit en el que esta para irse a la izquierda o a la derecha, cuando detecta que ya ha llegado a un nodo hoja, regresa en byteToWrite el valor del byte dado la cadena de bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">HuffmanTree</td><td>el arbol de Huffman </td></tr>
    <tr><td class="paramname">cadena</td><td>la cadena de bytes leidos del archivo comprimido </td></tr>
    <tr><td class="paramname">posInString</td><td>la posicion del arreglo de la cadena </td></tr>
    <tr><td class="paramname">posInBits</td><td>la posicion de bits en la que vamos en relacion a un byte </td></tr>
    <tr><td class="paramname">byteToWrite</td><td>la variable donde guardaremos el byte correspondiente </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>la posicion en bits en donde nos quedamos en relacion a un byte </dd></dl>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;{</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="HuffmanStructures_8h.html#a86b35899288a51584c43613160971dc8">isLeaf</a>(HuffmanTree))</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        *byteToWrite = HuffmanTree-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.<a class="code" href="structdata.html#af27bef4b0c09016974738690d89009f4">byte</a>;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">return</span> posInBits;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">if</span> (posInBits &lt; 0)</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            (*posInString)++;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            posInBits = 7;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        }</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">if</span> (((<span class="keywordtype">int</span>)CONSULTARBIT(cadena[(*posInString)], (posInBits))) == 0)</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="HuffmanStructures_8h.html#a9f60f86711915027587cc7e51824530f">getCharacters</a>(HuffmanTree-&gt;<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a>, cadena, posInString, (posInBits)-1, byteToWrite);</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="HuffmanStructures_8h.html#a9f60f86711915027587cc7e51824530f">getCharacters</a>(HuffmanTree-&gt;<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a>, cadena, posInString, posInBits - 1, byteToWrite);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    }</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_a9f60f86711915027587cc7e51824530f"><div class="ttname"><a href="HuffmanStructures_8h.html#a9f60f86711915027587cc7e51824530f">getCharacters</a></div><div class="ttdeci">int getCharacters(struct node *HuffmanTree, unsigned char *cadena, int *posInString, int posInBits, unsigned char *byteToWrite)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:48</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00041">data::byte</a>, <a class="el" href="#l00057">node::data</a>, and <a class="el" href="#l00011">isLeaf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00061">writeFile()</a>.</p>

</div>
</div>
<a id="a7cf9aa045cba65e7fbb1f3a9df39f7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf9aa045cba65e7fbb1f3a9df39f7e7">&#9670;&nbsp;</a></span>heapify_bottom_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void heapify_bottom_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordena los elementos del arreglo de nodos, haciendo que el elemento mas peque√±o sea la rama principal de nuestro arbol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a></td><td>es el monticulo al que vamos a ordenar su arreglo de nodos </td></tr>
    <tr><td class="paramname">index</td><td>es el indice en este caso el numero de elementos que hay que ordenar </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;{</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *temp;</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keywordtype">int</span> parent_node = (index - 1) / 2;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keywordflow">if</span> (heap-&gt;arrayOfNodes[parent_node]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency &gt; heap-&gt;arrayOfNodes[index]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency)</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        temp = heap-&gt;arrayOfNodes[parent_node];</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        heap-&gt;arrayOfNodes[parent_node] = heap-&gt;arrayOfNodes[index];</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        heap-&gt;arrayOfNodes[index] = temp;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#a7cf9aa045cba65e7fbb1f3a9df39f7e7">heapify_bottom_top</a>(heap, parent_node);</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_a7cf9aa045cba65e7fbb1f3a9df39f7e7"><div class="ttname"><a href="HuffmanStructures_8h.html#a7cf9aa045cba65e7fbb1f3a9df39f7e7">heapify_bottom_top</a></div><div class="ttdeci">void heapify_bottom_top(Heap *heap, int index)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:91</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00057">node::data</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00081">insert()</a>.</p>

</div>
</div>
<a id="af0b6a0088c5c75b15e4b9d2987f44c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b6a0088c5c75b15e4b9d2987f44c97">&#9670;&nbsp;</a></span>heapify_top_bottom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void heapify_top_bottom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordena los elementos del arreglo de nodos, haciendo que el elemento mas peque√±o sea la rama principal de nuestro arbol,este lo usamos al momento de retirar el elemento principal de nuestro <a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a>, debido a que el ordenamiento lo realiza a partir de nuestra raiz hacia los elementos hijos del arbol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a></td><td>es el monticulo al que vamos a ordenar su arreglo de nodos </td></tr>
    <tr><td class="paramname">parent_node</td><td>es el indice del elemento padre de nuestro nodo para realizar </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;{</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="keywordtype">int</span> left = parent_node * 2 + 1;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordtype">int</span> right = parent_node * 2 + 2;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordtype">int</span> min;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *temp;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160; </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> &gt;= heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> || <a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> &lt; 0)</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> = -1;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> &gt;= heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> || <a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> &lt; 0)</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> = -1;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160; </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> != -1 &amp;&amp; heap-&gt;arrayOfNodes[<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a>]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency &lt; heap-&gt;arrayOfNodes[parent_node]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency)</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        min = <a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a>;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        min = parent_node;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> != -1 &amp;&amp; heap-&gt;arrayOfNodes[<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a>]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency &lt; heap-&gt;arrayOfNodes[min]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency)</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        min = <a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a>;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160; </div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keywordflow">if</span> (min != parent_node)</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        temp = heap-&gt;arrayOfNodes[min];</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        heap-&gt;arrayOfNodes[min] = heap-&gt;arrayOfNodes[parent_node];</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        heap-&gt;arrayOfNodes[parent_node] = temp;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160; </div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#af0b6a0088c5c75b15e4b9d2987f44c97">heapify_top_bottom</a>(heap, min);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_af0b6a0088c5c75b15e4b9d2987f44c97"><div class="ttname"><a href="HuffmanStructures_8h.html#af0b6a0088c5c75b15e4b9d2987f44c97">heapify_top_bottom</a></div><div class="ttdeci">void heapify_top_bottom(Heap *heap, int parent_node)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:104</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00072">Heap::count</a>, <a class="el" href="#l00057">node::data</a>, <a class="el" href="#l00055">node::left</a>, and <a class="el" href="#l00056">node::right</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00133">PopMin()</a>.</p>

</div>
</div>
<a id="a8480031dd4983d594484e5901c625109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8480031dd4983d594484e5901c625109">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserta Nodos en la estructura de datos, indicando el <a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a> donde se desea hacer la incersion, seguido del nodo que se desea insertar, simempre y cuando la capacidad de <a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a> no haya sido exedida.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>es el monticulo donde vamos a insertar el nodo </td></tr>
    <tr><td class="paramname">node</td><td>es el nodo a insertar dentro del monticulo </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;{</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">if</span> (heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> &lt; heap-&gt;<a class="code" href="structHeap.html#a6c59b42ad9bf8ff10feffe29bd0dfb44">capacity</a>)</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    {</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        heap-&gt;arrayOfNodes[heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a>] = <a class="code" href="structnode.html">node</a>;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#a7cf9aa045cba65e7fbb1f3a9df39f7e7">heapify_bottom_top</a>(heap, heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a>);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a>++;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00073">Heap::capacity</a>, <a class="el" href="#l00072">Heap::count</a>, and <a class="el" href="#l00091">heapify_bottom_top()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00151">insertTree()</a>, and <a class="el" href="#l00164">mergeTrees()</a>.</p>

</div>
</div>
<a id="a3af3472248b7ad1d7aef69d68fed158a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af3472248b7ad1d7aef69d68fed158a">&#9670;&nbsp;</a></span>insertTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertTree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdata.html">data</a>&#160;</td>
          <td class="paramname"><em>bytesFrecuency</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a>&#160;</td>
          <td class="paramname"><em>roots</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserta en la cola de prioridad los nodos. EL numero de nodos que inserta son los bytes distintos que aparecieron en el archivo</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytesFrecuency</td><td>el arreglo de struct donde viene el byte y su frecuencia </td></tr>
    <tr><td class="paramname">roots</td><td>el arreglo de nodos que trae todos los bytes y su frecuencia </td></tr>
    <tr><td class="paramname">heap</td><td>la cola de prioridad </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;{</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="keywordtype">int</span> i;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="keywordflow">for</span> (i = 0; i &lt; 256; i++)</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    {</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keywordflow">if</span> (bytesFrecuency[i].frequency &gt; 0)</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            <a class="code" href="HuffmanStructures_8h.html#a2c0c0384c7064b8c1011dd46b520f49e">pushTree</a>(&amp;roots[i], bytesFrecuency[i].<span class="keywordtype">byte</span>, bytesFrecuency[i].frequency);</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            <a class="code" href="HuffmanStructures_8h.html#a8480031dd4983d594484e5901c625109">insert</a>(heap, &amp;roots[i]);</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    }</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_a2c0c0384c7064b8c1011dd46b520f49e"><div class="ttname"><a href="HuffmanStructures_8h.html#a2c0c0384c7064b8c1011dd46b520f49e">pushTree</a></div><div class="ttdeci">void pushTree(struct node *root, unsigned char byte, int frecuency)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:14</div></div>
<div class="ttc" id="aHuffmanStructures_8h_html_a8480031dd4983d594484e5901c625109"><div class="ttname"><a href="HuffmanStructures_8h.html#a8480031dd4983d594484e5901c625109">insert</a></div><div class="ttdeci">void insert(Heap *heap, struct node *node)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:81</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00081">insert()</a>, and <a class="el" href="#l00014">pushTree()</a>.</p>

</div>
</div>
<a id="a5bad7da515387fa08a9179b311723e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bad7da515387fa08a9179b311723e2a">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isEmpty </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nos dice si nodo en el arbol de Huffman es vacio o no.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>el nodo a comparar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 si el arbol es vacio </dd>
<dd>
0 si el arbol no es vacio </dd></dl>
<div class="fragment"><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{ <span class="keywordflow">return</span> root == NULL; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="#l00032">getBits()</a>.</p>

</div>
</div>
<a id="a86b35899288a51584c43613160971dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b35899288a51584c43613160971dc8">&#9670;&nbsp;</a></span>isLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isLeaf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nos dice si nodo en el que estamos es un nodo hoja.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>el nodo a analizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 si el nodo es hoja </dd>
<dd>
0 si el nodo no es hoja </dd></dl>
<div class="fragment"><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;{ <span class="keywordflow">return</span> root-&gt;<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> == NULL &amp;&amp; root-&gt;<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> == NULL; }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00055">node::left</a>, and <a class="el" href="#l00056">node::right</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00032">getBits()</a>, and <a class="el" href="#l00048">getCharacters()</a>.</p>

</div>
</div>
<a id="ad5ab18632fd2e00d4bd9206a4d50e024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ab18632fd2e00d4bd9206a4d50e024">&#9670;&nbsp;</a></span>mergeNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnode.html">node</a>* mergeNodes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Une dos nodos en un nodo ancestro comun</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>el primer nodo a unir que estara del lado izquierdo </td></tr>
    <tr><td class="paramname">node2</td><td>el segundo nodo a unir que estara del lado derecho </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>el nodo comun que tiene como hijos a ambos nodos </dd></dl>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *new_node = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structnode.html">node</a>));</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    new_node-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.<a class="code" href="structdata.html#af27bef4b0c09016974738690d89009f4">byte</a> = 0;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    new_node-&gt;<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> = node1;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    new_node-&gt;<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> = node2;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    new_node-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency = node1-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency + node2-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="keywordflow">return</span> new_node;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00041">data::byte</a>, <a class="el" href="#l00057">node::data</a>, <a class="el" href="#l00055">node::left</a>, and <a class="el" href="#l00056">node::right</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00164">mergeTrees()</a>.</p>

</div>
</div>
<a id="a7f02d9fd6fce765ac0cb694a3baa4b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f02d9fd6fce765ac0cb694a3baa4b28">&#9670;&nbsp;</a></span>mergeTrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnode.html">node</a>* mergeTrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Une todos los nodos hoja en un solo, llamado Arbol de Huffman. Usando la cola de prioridad saca los dos nodos de menor frecuencia suma sus dos frecuencia y los une en un nodo padre, haciendo esto hasta que solo quede un nodo padre el cual contiene a todos los nodos de los bytes leidos</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>la cola de prioridad con los nodos de los bytes leidos </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>el Arbol de Huffman </dd></dl>
<div class="fragment"><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;{</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160; </div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="keywordflow">while</span> (heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> &gt; 1)</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *node1 = <a class="code" href="HuffmanStructures_8h.html#a20d006cd7d0d91e05dd6c94fccb270a8">PopMin</a>(heap);</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *node2 = <a class="code" href="HuffmanStructures_8h.html#a20d006cd7d0d91e05dd6c94fccb270a8">PopMin</a>(heap);</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#a8480031dd4983d594484e5901c625109">insert</a>(heap, <a class="code" href="HuffmanStructures_8h.html#ad5ab18632fd2e00d4bd9206a4d50e024">mergeNodes</a>(node1, node2));</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    }</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="HuffmanStructures_8h.html#a20d006cd7d0d91e05dd6c94fccb270a8">PopMin</a>(heap);</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_a20d006cd7d0d91e05dd6c94fccb270a8"><div class="ttname"><a href="HuffmanStructures_8h.html#a20d006cd7d0d91e05dd6c94fccb270a8">PopMin</a></div><div class="ttdeci">struct node * PopMin(Heap *heap)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:133</div></div>
<div class="ttc" id="aHuffmanStructures_8h_html_ad5ab18632fd2e00d4bd9206a4d50e024"><div class="ttname"><a href="HuffmanStructures_8h.html#ad5ab18632fd2e00d4bd9206a4d50e024">mergeNodes</a></div><div class="ttdeci">struct node * mergeNodes(struct node *node1, struct node *node2)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:22</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00072">Heap::count</a>, <a class="el" href="#l00081">insert()</a>, <a class="el" href="#l00022">mergeNodes()</a>, and <a class="el" href="#l00133">PopMin()</a>.</p>

</div>
</div>
<a id="a20d006cd7d0d91e05dd6c94fccb270a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d006cd7d0d91e05dd6c94fccb270a8">&#9670;&nbsp;</a></span>PopMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnode.html">node</a>* PopMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Elmina el elemento mas peque√±o de una cola de prioridad</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a></td><td>Es la estructura heap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nodo eliminado </dd></dl>
<div class="fragment"><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;{</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *pop;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keywordflow">if</span> (heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> == 0)</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        printf(<span class="stringliteral">&quot;Heap is Empty.\n&quot;</span>);</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    pop = heap-&gt;arrayOfNodes[0];</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    heap-&gt;arrayOfNodes[0] = heap-&gt;arrayOfNodes[heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> - 1];</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a>--;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <a class="code" href="HuffmanStructures_8h.html#af0b6a0088c5c75b15e4b9d2987f44c97">heapify_top_bottom</a>(heap, 0);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keywordflow">return</span> pop;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00072">Heap::count</a>, and <a class="el" href="#l00104">heapify_top_bottom()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00164">mergeTrees()</a>.</p>

</div>
</div>
<a id="a2c0c0384c7064b8c1011dd46b520f49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0c0384c7064b8c1011dd46b520f49e">&#9670;&nbsp;</a></span>pushTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pushTree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frecuency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserta dado un byte y una frecuencia, las inserta en el nodo del arbol</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>el arbol de Huffman donde se insertara </td></tr>
    <tr><td class="paramname">byte</td><td>el byte correspondiente de su frecuencia </td></tr>
    <tr><td class="paramname">frecuency</td><td>la frecuencia correspondiente del byte </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;{</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    root-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency = frecuency;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    root-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.<a class="code" href="structdata.html#af27bef4b0c09016974738690d89009f4">byte</a> = byte;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    root-&gt;<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> = NULL;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    root-&gt;<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> = NULL;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00041">data::byte</a>, <a class="el" href="#l00057">node::data</a>, <a class="el" href="#l00055">node::left</a>, and <a class="el" href="#l00056">node::right</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00151">insertTree()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
