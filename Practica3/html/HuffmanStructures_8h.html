<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Huffman Algorithm: HuffmanStructures.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Huffman Algorithm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HuffmanStructures.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Las esctructuras y funciones usadas en el Algoritmo de Huffman.  
<a href="#details">More...</a></p>

<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbits.html">bits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Almacena el byte correspondiente, su tamaño y sus bits de la codificacion de Huffman.  <a href="structbits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdata.html">data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Almacena un byte y las veces que aparecio en el archivo.  <a href="structdata.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnode.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estructura del arbol de Huffman.  <a href="structnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeap.html">Heap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Almacena un arreglo de nodos.  <a href="structHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:abf81647b623c39b6e4e43581ddf666fe"><td class="memItemLeft" align="right" valign="top"><a id="abf81647b623c39b6e4e43581ddf666fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PESOBIT</b>(bpos)&#160;&#160;&#160;1 &lt;&lt; bpos</td></tr>
<tr class="separator:abf81647b623c39b6e4e43581ddf666fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a6bee91ee9e4ae83cccc49d35b864"><td class="memItemLeft" align="right" valign="top"><a id="a3c2a6bee91ee9e4ae83cccc49d35b864"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CONSULTARBIT</b>(var,  bpos)&#160;&#160;&#160;(*(unsigned *)&amp;var &amp; PESOBIT(bpos)) ? 1 : 0</td></tr>
<tr class="separator:a3c2a6bee91ee9e4ae83cccc49d35b864"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a705af815969c97892c0aaaa658f6c88c"><td class="memItemLeft" align="right" valign="top"><a id="a705af815969c97892c0aaaa658f6c88c"></a>
typedef struct <a class="el" href="structHeap.html">Heap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Heap</b></td></tr>
<tr class="separator:a705af815969c97892c0aaaa658f6c88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5bad7da515387fa08a9179b311723e2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a5bad7da515387fa08a9179b311723e2a">isEmpty</a> (struct <a class="el" href="structnode.html">node</a> *root)</td></tr>
<tr class="separator:a5bad7da515387fa08a9179b311723e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b35899288a51584c43613160971dc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a86b35899288a51584c43613160971dc8">isLeaf</a> (struct <a class="el" href="structnode.html">node</a> *root)</td></tr>
<tr class="separator:a86b35899288a51584c43613160971dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0c0384c7064b8c1011dd46b520f49e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a2c0c0384c7064b8c1011dd46b520f49e">pushTree</a> (struct <a class="el" href="structnode.html">node</a> *root, unsigned char byte, int frecuency)</td></tr>
<tr class="separator:a2c0c0384c7064b8c1011dd46b520f49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ab18632fd2e00d4bd9206a4d50e024"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#ad5ab18632fd2e00d4bd9206a4d50e024">mergeNodes</a> (struct <a class="el" href="structnode.html">node</a> *node1, struct <a class="el" href="structnode.html">node</a> *node2)</td></tr>
<tr class="separator:ad5ab18632fd2e00d4bd9206a4d50e024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b934a3197005f4d1d1343cd895ab0ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a8b934a3197005f4d1d1343cd895ab0ab">getBits</a> (struct <a class="el" href="structnode.html">node</a> *HuffmanTree, struct <a class="el" href="structbits.html">bits</a> bytesCode[], int <a class="el" href="structbits.html">bits</a>, int bitsSize)</td></tr>
<tr class="separator:a8b934a3197005f4d1d1343cd895ab0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f60f86711915027587cc7e51824530f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a9f60f86711915027587cc7e51824530f">getCharacters</a> (struct <a class="el" href="structnode.html">node</a> *HuffmanTree, unsigned char *cadena, int *posInString, int posInBits, unsigned char *byteToWrite)</td></tr>
<tr class="separator:a9f60f86711915027587cc7e51824530f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa991c0877759cd631105ec72160fb70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structHeap.html">Heap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#afa991c0877759cd631105ec72160fb70">CreateHeap</a> (int capacity)</td></tr>
<tr class="separator:afa991c0877759cd631105ec72160fb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8480031dd4983d594484e5901c625109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a8480031dd4983d594484e5901c625109">insert</a> (<a class="el" href="structHeap.html">Heap</a> *heap, struct <a class="el" href="structnode.html">node</a> *<a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="separator:a8480031dd4983d594484e5901c625109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf9aa045cba65e7fbb1f3a9df39f7e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a7cf9aa045cba65e7fbb1f3a9df39f7e7">heapify_bottom_top</a> (<a class="el" href="structHeap.html">Heap</a> *heap, int index)</td></tr>
<tr class="separator:a7cf9aa045cba65e7fbb1f3a9df39f7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b6a0088c5c75b15e4b9d2987f44c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#af0b6a0088c5c75b15e4b9d2987f44c97">heapify_top_bottom</a> (<a class="el" href="structHeap.html">Heap</a> *heap, int parent_node)</td></tr>
<tr class="separator:af0b6a0088c5c75b15e4b9d2987f44c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d006cd7d0d91e05dd6c94fccb270a8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a20d006cd7d0d91e05dd6c94fccb270a8">PopMin</a> (<a class="el" href="structHeap.html">Heap</a> *heap)</td></tr>
<tr class="separator:a20d006cd7d0d91e05dd6c94fccb270a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af3472248b7ad1d7aef69d68fed158a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a3af3472248b7ad1d7aef69d68fed158a">insertTree</a> (struct <a class="el" href="structdata.html">data</a> bytesFrecuency[], struct <a class="el" href="structnode.html">node</a> roots[], <a class="el" href="structHeap.html">Heap</a> *heap)</td></tr>
<tr class="separator:a3af3472248b7ad1d7aef69d68fed158a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f02d9fd6fce765ac0cb694a3baa4b28"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HuffmanStructures_8h.html#a7f02d9fd6fce765ac0cb694a3baa4b28">mergeTrees</a> (<a class="el" href="structHeap.html">Heap</a> *heap)</td></tr>
<tr class="separator:a7f02d9fd6fce765ac0cb694a3baa4b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Las esctructuras y funciones usadas en el Algoritmo de Huffman. </p>
<dl class="section author"><dt>Author</dt><dd>Victor Torres </dd>
<dd>
Leilani Sotelo </dd>
<dd>
Guillermo Sanchez </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>

<p class="definition">Definition in file <a class="el" href="">HuffmanStructures.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="afa991c0877759cd631105ec72160fb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa991c0877759cd631105ec72160fb70">&#9670;&nbsp;</a></span>CreateHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structHeap.html">Heap</a>* CreateHeap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Crea una estructura <a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a> en memoria dinamica dada su capacidad, la cual es un arreglo de nodos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>es la capacidad que queremos que tenga heap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>el apuntador a la estructura heap creada </dd></dl>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;{</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <a class="code" href="structHeap.html">Heap</a> *heap = (<a class="code" href="structHeap.html">Heap</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structHeap.html">Heap</a>));</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> = 0;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    heap-&gt;<a class="code" href="structHeap.html#a6c59b42ad9bf8ff10feffe29bd0dfb44">capacity</a> = capacity;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    heap-&gt;arrayOfNodes = (<span class="keyword">struct </span><a class="code" href="structnode.html">node</a> **)malloc(capacity * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structnode.html">node</a>));</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">return</span> heap;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;}</div>
<div class="ttc" id="astructHeap_html"><div class="ttname"><a href="structHeap.html">Heap</a></div><div class="ttdoc">Almacena un arreglo de nodos.</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:70</div></div>
<div class="ttc" id="astructHeap_html_a43405fb00a35877037a84f080aaf0aa7"><div class="ttname"><a href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">Heap::count</a></div><div class="ttdeci">int count</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:72</div></div>
<div class="ttc" id="astructHeap_html_a6c59b42ad9bf8ff10feffe29bd0dfb44"><div class="ttname"><a href="structHeap.html#a6c59b42ad9bf8ff10feffe29bd0dfb44">Heap::capacity</a></div><div class="ttdeci">int capacity</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:73</div></div>
<div class="ttc" id="astructnode_html"><div class="ttname"><a href="structnode.html">node</a></div><div class="ttdoc">Estructura del arbol de Huffman.</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:54</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00073">Heap::capacity</a>, and <a class="el" href="#l00072">Heap::count</a>.</p>

</div>
</div>
<a id="a8b934a3197005f4d1d1343cd895ab0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b934a3197005f4d1d1343cd895ab0ab">&#9670;&nbsp;</a></span>getBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getBits </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>HuffmanTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbits.html">bits</a>&#160;</td>
          <td class="paramname"><em>bytesCode</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitsSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtiene la codificaciond de Huffman correspondiente a los bytes. La guarda en un arreglo de struct junto con el tamaño de bits correspondiente. La codificacion se obtiene recorriendo el arbol inorder y cada vez registramos un 0 o un 1 si nos vamos a la izquierda o derecha, al final si es nodo hoja, guardamos lo que llevamos</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">HuffmanTree</td><td>el arbol de Huffman </td></tr>
    <tr><td class="paramname">bytesCode</td><td>el arreglo donde se guarda el byte, su codificacion y tamaño </td></tr>
    <tr><td class="paramname">bits</td><td>los bits con los que inicia el nodo que por defecto es 0 </td></tr>
    <tr><td class="paramname">bitsSize</td><td>el tamaño de los bits que por defecto es 0 </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="HuffmanStructures_8h.html#a5bad7da515387fa08a9179b311723e2a">isEmpty</a>(HuffmanTree))</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    {                                                                     <span class="comment">//if notempty</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#a8b934a3197005f4d1d1343cd895ab0ab">getBits</a>(HuffmanTree-&gt;<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a>, bytesCode, (<a class="code" href="structbits.html">bits</a> &lt;&lt; 1), sizeBits + 1); <span class="comment">// irte al nodo izq, sumandole un 0</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="HuffmanStructures_8h.html#a86b35899288a51584c43613160971dc8">isLeaf</a>(HuffmanTree))</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        {</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;            <span class="keywordtype">int</span> hashKey = HuffmanTree-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.<a class="code" href="structdata.html#af27bef4b0c09016974738690d89009f4">byte</a>;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            bytesCode[hashKey].<a class="code" href="structbits.html#a3e6347128690b18f31f4c12ba62f7796">bits</a> = <a class="code" href="structbits.html">bits</a>;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            bytesCode[hashKey].<a class="code" href="structbits.html#a5f11169dff38718ff57b0dc73b2da9e2">byte</a> = HuffmanTree-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.<a class="code" href="structdata.html#af27bef4b0c09016974738690d89009f4">byte</a>;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            bytesCode[hashKey].<a class="code" href="structbits.html#a15a0d838e9d402ead452a092c4f27e57">sizeBits</a> = sizeBits;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#a8b934a3197005f4d1d1343cd895ab0ab">getBits</a>(HuffmanTree-&gt;<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a>, bytesCode, (<a class="code" href="structbits.html">bits</a> &lt;&lt; 1) + 1, sizeBits + 1); <span class="comment">//irte al nodo der sumandole un 1</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    }</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_a5bad7da515387fa08a9179b311723e2a"><div class="ttname"><a href="HuffmanStructures_8h.html#a5bad7da515387fa08a9179b311723e2a">isEmpty</a></div><div class="ttdeci">int isEmpty(struct node *root)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:9</div></div>
<div class="ttc" id="aHuffmanStructures_8h_html_a86b35899288a51584c43613160971dc8"><div class="ttname"><a href="HuffmanStructures_8h.html#a86b35899288a51584c43613160971dc8">isLeaf</a></div><div class="ttdeci">int isLeaf(struct node *root)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:11</div></div>
<div class="ttc" id="aHuffmanStructures_8h_html_a8b934a3197005f4d1d1343cd895ab0ab"><div class="ttname"><a href="HuffmanStructures_8h.html#a8b934a3197005f4d1d1343cd895ab0ab">getBits</a></div><div class="ttdeci">void getBits(struct node *HuffmanTree, struct bits bytesCode[], int bits, int bitsSize)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:32</div></div>
<div class="ttc" id="astructbits_html"><div class="ttname"><a href="structbits.html">bits</a></div><div class="ttdoc">Almacena el byte correspondiente, su tamaño y sus bits de la codificacion de Huffman.</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:25</div></div>
<div class="ttc" id="astructbits_html_a15a0d838e9d402ead452a092c4f27e57"><div class="ttname"><a href="structbits.html#a15a0d838e9d402ead452a092c4f27e57">bits::sizeBits</a></div><div class="ttdeci">int sizeBits</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:27</div></div>
<div class="ttc" id="astructbits_html_a3e6347128690b18f31f4c12ba62f7796"><div class="ttname"><a href="structbits.html#a3e6347128690b18f31f4c12ba62f7796">bits::bits</a></div><div class="ttdeci">int bits</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:28</div></div>
<div class="ttc" id="astructbits_html_a5f11169dff38718ff57b0dc73b2da9e2"><div class="ttname"><a href="structbits.html#a5f11169dff38718ff57b0dc73b2da9e2">bits::byte</a></div><div class="ttdeci">unsigned char byte</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:26</div></div>
<div class="ttc" id="astructdata_html_af27bef4b0c09016974738690d89009f4"><div class="ttname"><a href="structdata.html#af27bef4b0c09016974738690d89009f4">data::byte</a></div><div class="ttdeci">int byte</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:41</div></div>
<div class="ttc" id="astructnode_html_a214bcb685bd669e3742fb8cf0b1baf36"><div class="ttname"><a href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">node::left</a></div><div class="ttdeci">struct node * left</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:55</div></div>
<div class="ttc" id="astructnode_html_a567ee9cc94939a22d38d21b7b5db2023"><div class="ttname"><a href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">node::right</a></div><div class="ttdeci">struct node * right</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:56</div></div>
<div class="ttc" id="astructnode_html_ac559c68027629d3f87ee49a6f8c839e6"><div class="ttname"><a href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">node::data</a></div><div class="ttdeci">struct data data</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.h:57</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00028">bits::bits</a>, <a class="el" href="#l00026">bits::byte</a>, <a class="el" href="#l00041">data::byte</a>, <a class="el" href="#l00057">node::data</a>, <a class="el" href="#l00009">isEmpty()</a>, <a class="el" href="#l00011">isLeaf()</a>, <a class="el" href="#l00055">node::left</a>, <a class="el" href="#l00056">node::right</a>, and <a class="el" href="#l00027">bits::sizeBits</a>.</p>

</div>
</div>
<a id="a9f60f86711915027587cc7e51824530f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f60f86711915027587cc7e51824530f">&#9670;&nbsp;</a></span>getCharacters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getCharacters </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>HuffmanTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>cadena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>posInString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posInBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>byteToWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtiene el byte correspondiente a la codificacion de Huffman. Recorre el arbol analizando si es 0 o 1 el bit en el que esta para irse a la izquierda o a la derecha, cuando detecta que ya ha llegado a un nodo hoja, regresa en byteToWrite el valor del byte dado la cadena de bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">HuffmanTree</td><td>el arbol de Huffman </td></tr>
    <tr><td class="paramname">cadena</td><td>la cadena de bytes leidos del archivo comprimido </td></tr>
    <tr><td class="paramname">posInString</td><td>la posicion del arreglo de la cadena </td></tr>
    <tr><td class="paramname">posInBits</td><td>la posicion de bits en la que vamos en relacion a un byte </td></tr>
    <tr><td class="paramname">byteToWrite</td><td>la variable donde guardaremos el byte correspondiente </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>la posicion en bits en donde nos quedamos en relacion a un byte </dd></dl>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;{</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="HuffmanStructures_8h.html#a86b35899288a51584c43613160971dc8">isLeaf</a>(HuffmanTree))</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        *byteToWrite = HuffmanTree-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.<a class="code" href="structdata.html#af27bef4b0c09016974738690d89009f4">byte</a>;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">return</span> posInBits;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">if</span> (posInBits &lt; 0)</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            (*posInString)++;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            posInBits = 7;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        }</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">if</span> (((<span class="keywordtype">int</span>)CONSULTARBIT(cadena[(*posInString)], (posInBits))) == 0)</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="HuffmanStructures_8h.html#a9f60f86711915027587cc7e51824530f">getCharacters</a>(HuffmanTree-&gt;<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a>, cadena, posInString, (posInBits)-1, byteToWrite);</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="HuffmanStructures_8h.html#a9f60f86711915027587cc7e51824530f">getCharacters</a>(HuffmanTree-&gt;<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a>, cadena, posInString, posInBits - 1, byteToWrite);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    }</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_a9f60f86711915027587cc7e51824530f"><div class="ttname"><a href="HuffmanStructures_8h.html#a9f60f86711915027587cc7e51824530f">getCharacters</a></div><div class="ttdeci">int getCharacters(struct node *HuffmanTree, unsigned char *cadena, int *posInString, int posInBits, unsigned char *byteToWrite)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:48</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00041">data::byte</a>, <a class="el" href="#l00057">node::data</a>, and <a class="el" href="#l00011">isLeaf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00061">writeFile()</a>.</p>

</div>
</div>
<a id="a7cf9aa045cba65e7fbb1f3a9df39f7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf9aa045cba65e7fbb1f3a9df39f7e7">&#9670;&nbsp;</a></span>heapify_bottom_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void heapify_bottom_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordena los elementos del arreglo de nodos, haciendo que el elemento mas pequeño sea la rama principal de nuestro arbol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a></td><td>es el monticulo al que vamos a ordenar su arreglo de nodos </td></tr>
    <tr><td class="paramname">index</td><td>es el indice en este caso el numero de elementos que hay que ordenar </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;{</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *temp;</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keywordtype">int</span> parent_node = (index - 1) / 2;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keywordflow">if</span> (heap-&gt;arrayOfNodes[parent_node]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency &gt; heap-&gt;arrayOfNodes[index]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency)</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        temp = heap-&gt;arrayOfNodes[parent_node];</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        heap-&gt;arrayOfNodes[parent_node] = heap-&gt;arrayOfNodes[index];</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        heap-&gt;arrayOfNodes[index] = temp;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#a7cf9aa045cba65e7fbb1f3a9df39f7e7">heapify_bottom_top</a>(heap, parent_node);</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_a7cf9aa045cba65e7fbb1f3a9df39f7e7"><div class="ttname"><a href="HuffmanStructures_8h.html#a7cf9aa045cba65e7fbb1f3a9df39f7e7">heapify_bottom_top</a></div><div class="ttdeci">void heapify_bottom_top(Heap *heap, int index)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:91</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00057">node::data</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00081">insert()</a>.</p>

</div>
</div>
<a id="af0b6a0088c5c75b15e4b9d2987f44c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b6a0088c5c75b15e4b9d2987f44c97">&#9670;&nbsp;</a></span>heapify_top_bottom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void heapify_top_bottom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordena los elementos del arreglo de nodos, haciendo que el elemento mas pequeño sea la rama principal de nuestro arbol,este lo usamos al momento de retirar el elemento principal de nuestro <a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a>, debido a que el ordenamiento lo realiza a partir de nuestra raiz hacia los elementos hijos del arbol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a></td><td>es el monticulo al que vamos a ordenar su arreglo de nodos </td></tr>
    <tr><td class="paramname">parent_node</td><td>es el indice del elemento padre de nuestro nodo para realizar </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;{</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="keywordtype">int</span> left = parent_node * 2 + 1;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordtype">int</span> right = parent_node * 2 + 2;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordtype">int</span> min;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *temp;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160; </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> &gt;= heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> || <a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> &lt; 0)</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> = -1;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> &gt;= heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> || <a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> &lt; 0)</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> = -1;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160; </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> != -1 &amp;&amp; heap-&gt;arrayOfNodes[<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a>]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency &lt; heap-&gt;arrayOfNodes[parent_node]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency)</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        min = <a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a>;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        min = parent_node;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> != -1 &amp;&amp; heap-&gt;arrayOfNodes[<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a>]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency &lt; heap-&gt;arrayOfNodes[min]-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency)</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        min = <a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a>;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160; </div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keywordflow">if</span> (min != parent_node)</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        temp = heap-&gt;arrayOfNodes[min];</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        heap-&gt;arrayOfNodes[min] = heap-&gt;arrayOfNodes[parent_node];</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        heap-&gt;arrayOfNodes[parent_node] = temp;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160; </div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#af0b6a0088c5c75b15e4b9d2987f44c97">heapify_top_bottom</a>(heap, min);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_af0b6a0088c5c75b15e4b9d2987f44c97"><div class="ttname"><a href="HuffmanStructures_8h.html#af0b6a0088c5c75b15e4b9d2987f44c97">heapify_top_bottom</a></div><div class="ttdeci">void heapify_top_bottom(Heap *heap, int parent_node)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:104</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00072">Heap::count</a>, <a class="el" href="#l00057">node::data</a>, <a class="el" href="#l00055">node::left</a>, and <a class="el" href="#l00056">node::right</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00133">PopMin()</a>.</p>

</div>
</div>
<a id="a8480031dd4983d594484e5901c625109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8480031dd4983d594484e5901c625109">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserta Nodos en la estructura de datos, indicando el <a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a> donde se desea hacer la incersion, seguido del nodo que se desea insertar, simempre y cuando la capacidad de <a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a> no haya sido exedida.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>es el monticulo donde vamos a insertar el nodo </td></tr>
    <tr><td class="paramname">node</td><td>es el nodo a insertar dentro del monticulo </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;{</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">if</span> (heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> &lt; heap-&gt;<a class="code" href="structHeap.html#a6c59b42ad9bf8ff10feffe29bd0dfb44">capacity</a>)</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    {</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        heap-&gt;arrayOfNodes[heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a>] = <a class="code" href="structnode.html">node</a>;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#a7cf9aa045cba65e7fbb1f3a9df39f7e7">heapify_bottom_top</a>(heap, heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a>);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a>++;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00073">Heap::capacity</a>, <a class="el" href="#l00072">Heap::count</a>, and <a class="el" href="#l00091">heapify_bottom_top()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00151">insertTree()</a>, and <a class="el" href="#l00164">mergeTrees()</a>.</p>

</div>
</div>
<a id="a3af3472248b7ad1d7aef69d68fed158a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af3472248b7ad1d7aef69d68fed158a">&#9670;&nbsp;</a></span>insertTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertTree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdata.html">data</a>&#160;</td>
          <td class="paramname"><em>bytesFrecuency</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a>&#160;</td>
          <td class="paramname"><em>roots</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserta en la cola de prioridad los nodos. EL numero de nodos que inserta son los bytes distintos que aparecieron en el archivo</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytesFrecuency</td><td>el arreglo de struct donde viene el byte y su frecuencia </td></tr>
    <tr><td class="paramname">roots</td><td>el arreglo de nodos que trae todos los bytes y su frecuencia </td></tr>
    <tr><td class="paramname">heap</td><td>la cola de prioridad </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;{</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="keywordtype">int</span> i;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="keywordflow">for</span> (i = 0; i &lt; 256; i++)</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    {</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keywordflow">if</span> (bytesFrecuency[i].frequency &gt; 0)</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            <a class="code" href="HuffmanStructures_8h.html#a2c0c0384c7064b8c1011dd46b520f49e">pushTree</a>(&amp;roots[i], bytesFrecuency[i].<span class="keywordtype">byte</span>, bytesFrecuency[i].frequency);</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            <a class="code" href="HuffmanStructures_8h.html#a8480031dd4983d594484e5901c625109">insert</a>(heap, &amp;roots[i]);</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    }</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_a2c0c0384c7064b8c1011dd46b520f49e"><div class="ttname"><a href="HuffmanStructures_8h.html#a2c0c0384c7064b8c1011dd46b520f49e">pushTree</a></div><div class="ttdeci">void pushTree(struct node *root, unsigned char byte, int frecuency)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:14</div></div>
<div class="ttc" id="aHuffmanStructures_8h_html_a8480031dd4983d594484e5901c625109"><div class="ttname"><a href="HuffmanStructures_8h.html#a8480031dd4983d594484e5901c625109">insert</a></div><div class="ttdeci">void insert(Heap *heap, struct node *node)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:81</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00081">insert()</a>, and <a class="el" href="#l00014">pushTree()</a>.</p>

</div>
</div>
<a id="a5bad7da515387fa08a9179b311723e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bad7da515387fa08a9179b311723e2a">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isEmpty </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nos dice si nodo en el arbol de Huffman es vacio o no.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>el nodo a comparar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 si el arbol es vacio </dd>
<dd>
0 si el arbol no es vacio </dd></dl>
<div class="fragment"><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{ <span class="keywordflow">return</span> root == NULL; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="#l00032">getBits()</a>.</p>

</div>
</div>
<a id="a86b35899288a51584c43613160971dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b35899288a51584c43613160971dc8">&#9670;&nbsp;</a></span>isLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isLeaf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nos dice si nodo en el que estamos es un nodo hoja.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>el nodo a analizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 si el nodo es hoja </dd>
<dd>
0 si el nodo no es hoja </dd></dl>
<div class="fragment"><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;{ <span class="keywordflow">return</span> root-&gt;<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> == NULL &amp;&amp; root-&gt;<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> == NULL; }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00055">node::left</a>, and <a class="el" href="#l00056">node::right</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00032">getBits()</a>, and <a class="el" href="#l00048">getCharacters()</a>.</p>

</div>
</div>
<a id="ad5ab18632fd2e00d4bd9206a4d50e024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ab18632fd2e00d4bd9206a4d50e024">&#9670;&nbsp;</a></span>mergeNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnode.html">node</a>* mergeNodes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Une dos nodos en un nodo ancestro comun</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>el primer nodo a unir que estara del lado izquierdo </td></tr>
    <tr><td class="paramname">node2</td><td>el segundo nodo a unir que estara del lado derecho </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>el nodo comun que tiene como hijos a ambos nodos </dd></dl>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *new_node = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structnode.html">node</a>));</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    new_node-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.<a class="code" href="structdata.html#af27bef4b0c09016974738690d89009f4">byte</a> = 0;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    new_node-&gt;<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> = node1;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    new_node-&gt;<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> = node2;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    new_node-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency = node1-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency + node2-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="keywordflow">return</span> new_node;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00041">data::byte</a>, <a class="el" href="#l00057">node::data</a>, <a class="el" href="#l00055">node::left</a>, and <a class="el" href="#l00056">node::right</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00164">mergeTrees()</a>.</p>

</div>
</div>
<a id="a7f02d9fd6fce765ac0cb694a3baa4b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f02d9fd6fce765ac0cb694a3baa4b28">&#9670;&nbsp;</a></span>mergeTrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnode.html">node</a>* mergeTrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Une todos los nodos hoja en un solo, llamado Arbol de Huffman. Usando la cola de prioridad saca los dos nodos de menor frecuencia suma sus dos frecuencia y los une en un nodo padre, haciendo esto hasta que solo quede un nodo padre el cual contiene a todos los nodos de los bytes leidos</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>la cola de prioridad con los nodos de los bytes leidos </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>el Arbol de Huffman </dd></dl>
<div class="fragment"><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;{</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160; </div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="keywordflow">while</span> (heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> &gt; 1)</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *node1 = <a class="code" href="HuffmanStructures_8h.html#a20d006cd7d0d91e05dd6c94fccb270a8">PopMin</a>(heap);</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *node2 = <a class="code" href="HuffmanStructures_8h.html#a20d006cd7d0d91e05dd6c94fccb270a8">PopMin</a>(heap);</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <a class="code" href="HuffmanStructures_8h.html#a8480031dd4983d594484e5901c625109">insert</a>(heap, <a class="code" href="HuffmanStructures_8h.html#ad5ab18632fd2e00d4bd9206a4d50e024">mergeNodes</a>(node1, node2));</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    }</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="HuffmanStructures_8h.html#a20d006cd7d0d91e05dd6c94fccb270a8">PopMin</a>(heap);</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;}</div>
<div class="ttc" id="aHuffmanStructures_8h_html_a20d006cd7d0d91e05dd6c94fccb270a8"><div class="ttname"><a href="HuffmanStructures_8h.html#a20d006cd7d0d91e05dd6c94fccb270a8">PopMin</a></div><div class="ttdeci">struct node * PopMin(Heap *heap)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:133</div></div>
<div class="ttc" id="aHuffmanStructures_8h_html_ad5ab18632fd2e00d4bd9206a4d50e024"><div class="ttname"><a href="HuffmanStructures_8h.html#ad5ab18632fd2e00d4bd9206a4d50e024">mergeNodes</a></div><div class="ttdeci">struct node * mergeNodes(struct node *node1, struct node *node2)</div><div class="ttdef"><b>Definition:</b> HuffmanStructures.c:22</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00072">Heap::count</a>, <a class="el" href="#l00081">insert()</a>, <a class="el" href="#l00022">mergeNodes()</a>, and <a class="el" href="#l00133">PopMin()</a>.</p>

</div>
</div>
<a id="a20d006cd7d0d91e05dd6c94fccb270a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d006cd7d0d91e05dd6c94fccb270a8">&#9670;&nbsp;</a></span>PopMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnode.html">node</a>* PopMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap.html">Heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Elmina el elemento mas pequeño de una cola de prioridad</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structHeap.html" title="Almacena un arreglo de nodos.">Heap</a></td><td>Es la estructura heap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nodo eliminado </dd></dl>
<div class="fragment"><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;{</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    <span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *pop;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keywordflow">if</span> (heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> == 0)</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        printf(<span class="stringliteral">&quot;Heap is Empty.\n&quot;</span>);</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    pop = heap-&gt;arrayOfNodes[0];</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    heap-&gt;arrayOfNodes[0] = heap-&gt;arrayOfNodes[heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a> - 1];</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    heap-&gt;<a class="code" href="structHeap.html#a43405fb00a35877037a84f080aaf0aa7">count</a>--;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <a class="code" href="HuffmanStructures_8h.html#af0b6a0088c5c75b15e4b9d2987f44c97">heapify_top_bottom</a>(heap, 0);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keywordflow">return</span> pop;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00072">Heap::count</a>, and <a class="el" href="#l00104">heapify_top_bottom()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00164">mergeTrees()</a>.</p>

</div>
</div>
<a id="a2c0c0384c7064b8c1011dd46b520f49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0c0384c7064b8c1011dd46b520f49e">&#9670;&nbsp;</a></span>pushTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pushTree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frecuency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserta dado un byte y una frecuencia, las inserta en el nodo del arbol</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>el arbol de Huffman donde se insertara </td></tr>
    <tr><td class="paramname">byte</td><td>el byte correspondiente de su frecuencia </td></tr>
    <tr><td class="paramname">frecuency</td><td>la frecuencia correspondiente del byte </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;{</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    root-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.frequency = frecuency;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    root-&gt;<a class="code" href="structnode.html#ac559c68027629d3f87ee49a6f8c839e6">data</a>.<a class="code" href="structdata.html#af27bef4b0c09016974738690d89009f4">byte</a> = byte;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    root-&gt;<a class="code" href="structnode.html#a214bcb685bd669e3742fb8cf0b1baf36">left</a> = NULL;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    root-&gt;<a class="code" href="structnode.html#a567ee9cc94939a22d38d21b7b5db2023">right</a> = NULL;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00041">data::byte</a>, <a class="el" href="#l00057">node::data</a>, <a class="el" href="#l00055">node::left</a>, and <a class="el" href="#l00056">node::right</a>.</p>

<p class="reference">Referenced by <a class="el" href="#l00151">insertTree()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
